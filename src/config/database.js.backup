/**
 * Configura√ß√£o de Banco de Dados - Detec√ß√£o Autom√°tica
 * Sistema Multi-Tenant com suporte a SQLite (dev) e PostgreSQL (prod)
 */

// Detectar qual banco usar baseado no ambiente
const usePostgreSQL = process.env.NODE_ENV === 'production' || 
                     process.env.DB_TYPE === 'postgresql' || 
                     process.env.USE_POSTGRESQL === 'true';

let pool, dbConfig;

if (usePostgreSQL) {
  console.log('üêò Usando PostgreSQL para produ√ß√£o');
  
  // Importar configura√ß√£o PostgreSQL
  const postgresConfig = require('../../config/database');
  pool = postgresConfig;
  dbConfig = {
    type: 'postgresql',
    host: process.env.DB_HOST || 'localhost',
    port: process.env.DB_PORT || 5432,
    database: process.env.DB_NAME || 'agendamento'
  };
} else {
  console.log('üóÉÔ∏è Usando SQLite para desenvolvimento');
  
  // Importar configura√ß√£o SQLite
  const sqliteConfig = require('./database-sqlite');
  pool = sqliteConfig.pool;
  dbConfig = sqliteConfig.dbConfig;
}

// Fun√ß√£o para testar conex√£o
async function testConnection() {
  try {
    if (usePostgreSQL) {
      const result = await pool.query('SELECT NOW() as current_time, version() as db_version');
      return {
        success: true,
        type: 'postgresql',
        timestamp: result.rows[0].current_time,
        version: result.rows[0].db_version,
        pool: {
          totalCount: pool.totalCount || 0,
          idleCount: pool.idleCount || 0,
          waitingCount: pool.waitingCount || 0
        }
      };
    } else {
      const result = await pool.query('SELECT datetime("now") as current_time, sqlite_version() as db_version');
      return {
        success: true,
        type: 'sqlite',
        timestamp: result.rows[0].current_time,
        version: result.rows[0].db_version,
        pool: {
          totalCount: 1,
          idleCount: 0,
          waitingCount: 0
        }
      };
    }
  } catch (error) {
    return {
      success: false,
      type: usePostgreSQL ? 'postgresql' : 'sqlite',
      error: error.message
    };
  }
}

// Fun√ß√£o para executar queries com compatibilidade
async function executeQuery(query, params = []) {
  if (usePostgreSQL) {
    return await pool.query(query, params);
  } else {
    // Converter placeholders PostgreSQL para SQLite
    const sqliteQuery = query.replace(/\$(\d+)/g, '?');
    return await pool.query(sqliteQuery, params);
  }
}

// Fun√ß√£o para executar transa√ß√µes
async function executeTransaction(callback) {
  if (usePostgreSQL) {
    const client = await pool.connect();
    try {
      await client.query('BEGIN');
      const result = await callback(client);
      await client.query('COMMIT');
      return { success: true, result };
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  } else {
    // SQLite n√£o tem transa√ß√µes expl√≠citas como PostgreSQL
    try {
      await pool.query('BEGIN TRANSACTION');
      const result = await callback(pool);
      await pool.query('COMMIT');
      return { success: true, result };
    } catch (error) {
      await pool.query('ROLLBACK');
      throw error;
    }
  }
}

// Exportar configura√ß√£o
module.exports = {
  pool,
  dbConfig,
  testConnection,
  executeQuery,
  executeTransaction,
  isPostgreSQL: usePostgreSQL,
  isSQLite: !usePostgreSQL
};
