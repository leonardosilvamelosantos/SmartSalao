const WhatsAppInstance = require('./WhatsAppInstance');
const SessionManager = require('./SessionManager');
const ConnectionManager = require('./ConnectionManager');
const path = require('path');
const fs = require('fs');

/**
 * Gerenciador de Inst√¢ncias WhatsApp Multi-Tenant
 * Baseado no Multi Zap, adaptado para SQLite e sistema de agendamentos
 */
class InstanceManager {
  constructor() {
    this.instances = new Map();
    this.sessions = new Map();
    this.maxInstances = 10; // Limite de inst√¢ncias simult√¢neas
    this.cleanupInterval = null;
    this.sessionManager = new SessionManager();
    this.connectionManager = new ConnectionManager();
    
    // Iniciar limpeza autom√°tica
    this.startCleanupInterval();
    
    // N√ÉO carregar inst√¢ncias automaticamente - apenas quando solicitado
    // this.loadExistingInstances();
  }

  /**
   * Criar nova inst√¢ncia para um tenant
   * @param {string} tenantId - ID do tenant
   * @param {Object} options - Op√ß√µes de configura√ß√£o
   * @returns {Promise<Object>} - Resultado da cria√ß√£o
   */
  async createInstance(tenantId, options = {}) {
    try {
      // Verificar se j√° existe inst√¢ncia ativa
      if (this.instances.has(tenantId)) {
        const existing = this.instances.get(tenantId);
        if (existing.isConnected) {
          console.log(`‚úÖ Inst√¢ncia j√° existe e est√° conectada para tenant: ${tenantId}`);
          return { success: true, message: 'Inst√¢ncia j√° existe e est√° conectada' };
        }
        // Se est√° conectando, aguardar ou retornar erro
        if (existing.isConnecting) {
          console.log(`‚è≥ Inst√¢ncia j√° est√° conectando para tenant: ${tenantId}`);
          return { success: false, error: 'Inst√¢ncia j√° est√° conectando' };
        }
        // Reutilizar inst√¢ncia existente desconectada
        console.log(`üîÑ Reutilizando inst√¢ncia existente para tenant: ${tenantId}`);
        const result = await existing.connect();
        if (result.success) {
          // Registrar no ConnectionManager se n√£o estiver
          if (!this.connectionManager.connections.has(tenantId)) {
            this.connectionManager.registerConnection(tenantId, existing);
          }
          return result;
        } else {
          console.log(`‚ùå Falha ao reconectar inst√¢ncia existente: ${result.error}`);
          return result;
        }
      }

      // Carregar inst√¢ncias existentes se necess√°rio
      await this.loadExistingInstances();
      
      // Verificar novamente se a inst√¢ncia foi carregada
      if (this.instances.has(tenantId)) {
        const existing = this.instances.get(tenantId);
        console.log(`üîÑ Inst√¢ncia carregada do disco para tenant: ${tenantId}`);
        const result = await existing.connect();
        if (result.success) {
          // Registrar no ConnectionManager se n√£o estiver
          if (!this.connectionManager.connections.has(tenantId)) {
            this.connectionManager.registerConnection(tenantId, existing);
          }
          return result;
        } else {
          console.log(`‚ùå Falha ao conectar inst√¢ncia carregada: ${result.error}`);
          return result;
        }
      }

      // Verificar limite de inst√¢ncias
      if (this.instances.size >= this.maxInstances) {
        return { success: false, error: 'Limite de inst√¢ncias atingido' };
      }

      console.log(`üîß Criando nova inst√¢ncia para tenant: ${tenantId}`);
      
      const instance = new WhatsAppInstance(tenantId, options);
      
      // Configurar eventos da inst√¢ncia
      this.setupInstanceEvents(instance);
      
      // Conectar inst√¢ncia
      const result = await instance.connect();
      
      if (result.success) {
        this.instances.set(tenantId, instance);
        
        // Registrar no ConnectionManager
        this.connectionManager.registerConnection(tenantId, instance);
        
        this.sessions.set(tenantId, {
          tenantId,
          createdAt: new Date(),
          lastActivity: new Date(),
          status: 'connecting'
        });

        // Salvar no banco de dados
        await this.sessionManager.saveInstance(tenantId, {
          status: 'connecting',
          createdAt: new Date(),
          lastActivity: new Date()
        });
      }
      
      return result;
    } catch (error) {
      console.error(`‚ùå Erro ao criar inst√¢ncia para tenant ${tenantId}:`, error.message);
      return { success: false, error: error.message };
    }
  }

  /**
   * Configurar eventos da inst√¢ncia
   * @param {WhatsAppInstance} instance - Inst√¢ncia WhatsApp
   */
  setupInstanceEvents(instance) {
    instance.on('connected', () => {
      const session = this.sessions.get(instance.tenantId);
      if (session) {
        session.status = 'connected';
        session.lastActivity = new Date();
      }
      
      // Atualizar no ConnectionManager
      this.connectionManager.updateStatus(instance.tenantId, 'connected');
      
      console.log(`‚úÖ Inst√¢ncia conectada: ${instance.tenantId}`);
      
      // Atualizar no banco
      this.sessionManager.updateInstanceStatus(instance.tenantId, 'connected');
    });

    instance.on('disconnected', (data) => {
      const session = this.sessions.get(instance.tenantId);
      if (session) {
        session.status = 'disconnected';
        session.lastActivity = new Date();
      }
      
      // Atualizar no ConnectionManager
      this.connectionManager.updateStatus(instance.tenantId, 'disconnected', data);
      
      if (process.env.LOG_WA_STATUS === 'true') {
        console.log(`üîå Inst√¢ncia desconectada: ${instance.tenantId}`, data);
      } else {
        console.log(`üîå Inst√¢ncia desconectada: ${instance.tenantId}`);
      }
      
      // Atualizar no banco
      this.sessionManager.updateInstanceStatus(instance.tenantId, 'disconnected');
    });

    instance.on('qr_generated', (qrData) => {
      const session = this.sessions.get(instance.tenantId);
      if (session) {
        session.qrCode = qrData;
        session.status = 'qr_ready';
      }
      if (process.env.LOG_WA_STATUS === 'true') {
        console.log(`üì± QR Code gerado para tenant: ${instance.tenantId}`);
      }
      
      // Salvar QR no banco
      this.sessionManager.saveQRCode(instance.tenantId, qrData);
    });

    instance.on('qr_expired', () => {
      if (process.env.LOG_WA_STATUS === 'true') {
        console.log(`‚è∞ QR Code expirado para tenant: ${instance.tenantId}, gerando novo...`);
      }
      
      // Limpar QR Code atual
      const session = this.sessions.get(instance.tenantId);
      if (session) {
        session.qrCode = null;
        session.status = 'disconnected';
      }
      
      // Tentar reconectar para gerar novo QR Code
      this.reconnectInstance(instance.tenantId);
    });

    instance.on('message', (messageData) => {
      const session = this.sessions.get(instance.tenantId);
      if (session) {
        session.lastActivity = new Date();
      }
      
      // Processar mensagem atrav√©s do sistema de agendamentos
      this.processMessage(instance.tenantId, messageData);
      
      // log reduzido
      // console.log(`üì® Mensagem processada para tenant: ${instance.tenantId}`);
    });

    instance.on('error', (error) => {
      console.error(`‚ùå Erro na inst√¢ncia ${instance.tenantId}:`, error.message);
    });

    instance.on('critical_error', (data) => {
      console.error(`üí• Erro cr√≠tico na inst√¢ncia ${instance.tenantId}:`, data);
      // Remover inst√¢ncia em caso de erro cr√≠tico
      this.removeInstance(instance.tenantId);
    });

    instance.on('credentials_expired', (data) => {
      console.log(`üîë Credenciais expiradas para tenant ${instance.tenantId}. Inst√¢ncia dispon√≠vel para reconex√£o via QR Code.`);
      const session = this.sessions.get(instance.tenantId);
      if (session) {
        session.status = 'credentials_expired';
        session.lastActivity = new Date();
      }
      
      // Atualizar no banco
      this.sessionManager.updateInstanceStatus(instance.tenantId, 'credentials_expired');
      
      // N√£o tentar reconectar automaticamente - aguardar a√ß√£o manual do usu√°rio
      console.log(`‚è∏Ô∏è Tenant ${instance.tenantId} aguardando reconex√£o manual via dashboard`);
    });
  }

  /**
   * Processar mensagem recebida
   * @param {string} tenantId - ID do tenant
   * @param {Object} messageData - Dados da mensagem
   */
  async processMessage(tenantId, messageData) {
    try {
      // Importar o processador de mensagens existente
      const BotProcessorService = require('../services/BotProcessorService');
      
      // Processar mensagem atrav√©s do sistema existente, incluindo tenantId no payload
      const response = await BotProcessorService.processMessage({ ...messageData, tenantId });
      
      if (response && response.to && response.message) {
        // Enviar resposta se necess√°rio
        await this.sendMessage(tenantId, response.to, response.message);
      }
    } catch (error) {
      console.error(`‚ùå Erro ao processar mensagem para tenant ${tenantId}:`, error.message);
    }
  }

  /**
   * Remover inst√¢ncia
   * @param {string} tenantId - ID do tenant
   * @returns {Promise<void>}
   */
  async removeInstance(tenantId) {
    try {
      const instance = this.instances.get(tenantId);
      if (instance) {
        await instance.disconnect();
        this.instances.delete(tenantId);
      }
      
      this.sessions.delete(tenantId);
      
      // Remover do banco
      await this.sessionManager.removeInstance(tenantId);
      
      console.log(`üóëÔ∏è Inst√¢ncia removida para tenant: ${tenantId}`);
    } catch (error) {
      console.error(`‚ùå Erro ao remover inst√¢ncia do tenant ${tenantId}:`, error.message);
    }
  }

  /**
   * Obter inst√¢ncia
   * @param {string} tenantId - ID do tenant
   * @returns {WhatsAppInstance|null} - Inst√¢ncia ou null
   */
  getInstance(tenantId) {
    return this.instances.get(tenantId);
  }

  /**
   * Obter status de uma inst√¢ncia (otimizado)
   * @param {string} tenantId - ID do tenant
   * @returns {Object} - Status da inst√¢ncia
   */
  getInstanceStatus(tenantId) {
    const instance = this.instances.get(tenantId);
    const session = this.sessions.get(tenantId);
    
    if (!instance || !session) {
      return { success: false, error: 'Inst√¢ncia n√£o encontrada' };
    }

    // Retornar status b√°sico sem logs desnecess√°rios
    return {
      success: true,
      tenantId: instance.tenantId,
      isConnected: instance.isConnected,
      qrCode: instance.qrCode,
      phoneNumber: instance.phoneNumber,
      connectionMethod: instance.options.connectionMethod,
      lastActivity: instance.lastActivity,
      retryCount: instance.retryCount,
      connectionAttempts: instance.connectionAttempts,
      connectionState: instance.sock?.ws?.readyState || 'disconnected',
      isConnecting: instance.isConnecting,
      user: instance.phoneNumber ? { name: 'Usu√°rio WhatsApp', phone: instance.phoneNumber } : null,
      session: session
    };
  }

  /**
   * Listar todas as inst√¢ncias
   * @returns {Array} - Lista de inst√¢ncias
   */
  getAllInstances() {
    const instances = [];
    
    for (const [tenantId, instance] of this.instances.entries()) {
      const session = this.sessions.get(tenantId);
      instances.push({
        tenantId,
        ...instance.getStatus(),
        session: session
      });
    }
    
    return instances;
  }

  /**
   * Reconectar inst√¢ncia para regenerar QR Code
   * @param {string} tenantId
   */
  async reconnectInstance(tenantId) {
    try {
      const instance = this.instances.get(tenantId);
      if (!instance) {
        console.log(`‚ö†Ô∏è Inst√¢ncia ${tenantId} n√£o encontrada para reconex√£o`);
        return;
      }

      // Evitar m√∫ltiplas reconex√µes concorrentes
      if (instance.isConnecting) {
        console.log(`‚è≥ Inst√¢ncia ${tenantId} j√° est√° conectando, ignorando reconex√£o.`);
        return;
      }

      console.log(`üîÑ Reabrindo conex√£o para regenerar QR do tenant ${tenantId}`);
      await instance.connect();
    } catch (error) {
      console.error(`‚ùå Erro ao reconectar inst√¢ncia ${tenantId}:`, error.message);
    }
  }

  /**
   * Enviar mensagem
   * @param {string} tenantId - ID do tenant
   * @param {string} to - Destinat√°rio
   * @param {string} message - Mensagem
   * @returns {Promise<Object>} - Resultado do envio
   */
  async sendMessage(tenantId, to, message) {
    try {
      const instance = this.instances.get(tenantId);
      if (!instance) {
        return { success: false, error: 'Inst√¢ncia n√£o encontrada' };
      }

      const result = await instance.sendMessage(to, message);
      
      // Log da mensagem no banco
      if (result.success) {
        await this.sessionManager.logMessage(tenantId, 'sent', to, message, 'text', result.messageId);
      }
      
      return result;
    } catch (error) {
      console.error(`‚ùå Erro ao enviar mensagem para tenant ${tenantId}:`, error.message);
      return { success: false, error: error.message };
    }
  }

  /**
   * Enviar m√≠dia
   * @param {string} tenantId - ID do tenant
   * @param {string} to - Destinat√°rio
   * @param {Object} media - Dados da m√≠dia
   * @param {string} caption - Legenda
   * @returns {Promise<Object>} - Resultado do envio
   */
  async sendMediaMessage(tenantId, to, media, caption = '') {
    try {
      const instance = this.instances.get(tenantId);
      if (!instance) {
        return { success: false, error: 'Inst√¢ncia n√£o encontrada' };
      }

      const result = await instance.sendMediaMessage(to, media, caption);
      
      // Log da mensagem no banco
      if (result.success) {
        await this.sessionManager.logMessage(tenantId, 'sent', to, caption || media.url, media.type, result.messageId);
      }
      
      return result;
    } catch (error) {
      console.error(`‚ùå Erro ao enviar m√≠dia para tenant ${tenantId}:`, error.message);
      return { success: false, error: error.message };
    }
  }

  /**
   * Solicitar c√≥digo de pareamento
   * @param {string} tenantId - ID do tenant
   * @param {string} phoneNumber - N√∫mero de telefone
   * @returns {Promise<Object>} - Resultado da solicita√ß√£o
   */
  async requestPairingCode(tenantId, phoneNumber) {
    try {
      const instance = this.instances.get(tenantId);
      if (!instance) {
        return { success: false, error: 'Inst√¢ncia n√£o encontrada' };
      }

      const result = await instance.requestPairingCode(phoneNumber);
      
      if (result.success) {
        // Salvar c√≥digo de pareamento no banco
        await this.sessionManager.savePairingCode(tenantId, result.pairingCode);
      }
      
      return result;
    } catch (error) {
      console.error(`‚ùå Erro ao solicitar c√≥digo de pareamento para tenant ${tenantId}:`, error.message);
      return { success: false, error: error.message };
    }
  }

  /**
   * Obter c√≥digo de pareamento
   * @param {string} tenantId - ID do tenant
   * @returns {Object|null} - C√≥digo de pareamento ou null
   */
  getPairingCode(tenantId) {
    const instance = this.instances.get(tenantId);
    if (!instance) {
      return null;
    }
    return instance.getPairingCode();
  }

  /**
   * Limpeza autom√°tica
   */
  startCleanupInterval() {
    this.cleanupInterval = setInterval(() => {
      this.cleanupInactiveInstances();
    }, 300000); // 5 minutos
  }

  /**
   * Limpar inst√¢ncias inativas
   */
  async cleanupInactiveInstances() {
    try {
      const now = new Date();
      const maxInactiveTime = 30 * 60 * 1000; // 30 minutos

      for (const [tenantId, session] of this.sessions.entries()) {
        const timeSinceActivity = now - session.lastActivity;
        
        if (timeSinceActivity > maxInactiveTime) {
          console.log(`üßπ Limpando inst√¢ncia inativa: ${tenantId}`);
          await this.removeInstance(tenantId);
        }
      }
    } catch (error) {
      console.error(`‚ùå Erro na limpeza autom√°tica:`, error.message);
    }
  }


  /**
   * Parar gerenciador
   */
  async stop() {
    try {
      if (this.cleanupInterval) {
        clearInterval(this.cleanupInterval);
      }

      // Desconectar todas as inst√¢ncias
      for (const [tenantId, instance] of this.instances.entries()) {
        await instance.disconnect();
      }

      this.instances.clear();
      this.sessions.clear();
      
      console.log(`üõë Gerenciador de inst√¢ncias parado`);
    } catch (error) {
      console.error(`‚ùå Erro ao parar gerenciador:`, error.message);
    }
  }

  /**
   * Obter status das conex√µes do ConnectionManager
   */
  getConnectionsStatus() {
    return this.connectionManager.getStatus();
  }

  /**
   * Carregar inst√¢ncias existentes manualmente
   */
  async loadExistingInstances() {
    try {
      const sessionsDir = './data/whatsapp-auth';
      
      if (!fs.existsSync(sessionsDir)) {
        console.log('üìÅ Diret√≥rio de sess√µes n√£o encontrado');
        return;
      }

      const sessionDirs = fs.readdirSync(sessionsDir, { withFileTypes: true })
        .filter(dirent => dirent.isDirectory())
        .map(dirent => dirent.name);

      console.log(`üîç Encontradas ${sessionDirs.length} sess√µes existentes:`, sessionDirs);

      const validSessions = [];

      for (const sessionDir of sessionDirs) {
        const sessionPath = path.join(sessionsDir, sessionDir);
        const credsPath = path.join(sessionPath, 'creds.json');
        
        // Verificar se tem credenciais v√°lidas
        if (fs.existsSync(credsPath)) {
          try {
            const creds = JSON.parse(fs.readFileSync(credsPath, 'utf8'));
            
            if (creds && creds.me && creds.me.id) {
              console.log(`üîÑ Carregando inst√¢ncia existente: ${sessionDir}`);
              
              // Criar inst√¢ncia sem conectar automaticamente
              const instance = new WhatsAppInstance(sessionDir, { autoConnect: false });
              
              // Configurar eventos
              this.setupInstanceEvents(instance);
              
              // Adicionar ao gerenciador
              this.instances.set(sessionDir, instance);
              this.sessions.set(sessionDir, {
                tenantId: sessionDir,
                createdAt: new Date(),
                lastActivity: new Date(),
                status: 'disconnected'
              });
              
              validSessions.push(sessionDir);
              console.log(`‚úÖ Inst√¢ncia ${sessionDir} carregada (pronta para conectar)`);
            }
          } catch (error) {
            console.error(`‚ùå Erro ao carregar sess√£o ${sessionDir}:`, error.message);
          }
        }
      }

      // Apenas carregar inst√¢ncias, N√ÉO conectar automaticamente
      if (validSessions.length > 0) {
        console.log(`üìã ${validSessions.length} inst√¢ncias carregadas (aguardando conex√£o manual)`);
        console.log(`üí° Use createInstance() para conectar um tenant espec√≠fico`);
      }
    } catch (error) {
      console.error(`‚ùå Erro ao carregar inst√¢ncias existentes:`, error.message);
    }
  }
}

module.exports = InstanceManager;
